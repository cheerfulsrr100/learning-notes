- [二-概述](#二-概述)
- [三-类型](#三-类型)
  - [类型](#类型)
- [四-函数](#四-函数)
  - [声明及调用函数](#声明及调用函数)
# 二-概述
* 创建ts工程: `npm install --save-dev typescript tslint @types/node`
* 执行tsc: `./node_modules/.bin/tsc`
* 使用node执行编译后文件: `node ./dist/index.js`
# 三-类型
* 类型层次结构
    ![](img-img-ts-programming/ts-class-hierarchical-structure.png)
* 约束类型: `变量名: 类型`
## 类型
* 别名
  * 声明别名: `type As = number`
* 交并集类型
  * 交集类型: `type C = A & B`
  * 并集类型: `type C = A | B`
* `any`: 未显式定义的类型tsc自动推断为`any`
* 基本类型
  * `unknown`: 
    * 使用受到限制, 并不能像`any`一样随意使用. 虽然是未知类型, 但必须显式注解
    * tsc无法自动推断; `any`可以自动推断
    * 可以比较
    * 在使用之前必须先证明它确实为某个类型. 使用`instanceof`或`typeof`
  * `boolean`: 
    * 可以比较和否定
    * 可以自动推断类型或值: `let b = true`; 可以明确指定类型或值: `let b: true = true // 使用了类型字面量, 即在类型中限定值`; 
  * `number`, `bigint`
    * 可以做数字运算
    * 可以自动推断或声明类型或值
    * `const`会直接将推断出值, `let`只会推断出类型
      ```
      let a = 123 // number
      const b = 567 // 567
      ```
  * `string`: 可以自动推断或声明类型或值
  * `symbol`:
    * 使用`const`声明的变量, tsc推导为`unique symbol`
    * tsc在编译时知道`unique symbol`类型的值绝不会与另一个`unique symbol`类型的值相等
* 对象
  * 如何声明对象类型
    * 生命为`object`: `let a: object`
    * 可以显式声明对象的结构: `let a: {b: number} = {b: 12}` 
    * 可以由tsc自动推断: `let a = {b: 12}` 
  * 对象遵循鸭子类型, 只要变量的结构与声明类型的结构一致即可
  * 可选属性
    * `let a: { c?: string }`: 可能有个类型为string的属性c
    * `let a: { [key: number]: boolean }`: 可能有任意多个数字属性, 类型为`boolean`
  * 索引签名`[key: T]: U`
    * 在这个对象中, 类型为`T`的键对应的值为`U`类型
    * `T`必须可以赋值给`number`或`string`
* 数组与元组
  * 数组
    * 声明数组
      ```typescript
      let a: string[] 
      let b: Array[string]  // 元组同理
      let c: readonly string[]
      let D: ReadonlyArray[string] // 元组同理
      ```
    * 类型推导: 数组离开定义的作用域后, ts将推导出一个最终类型
  * 元组
    * 定义
      * 是`数组`的子类, 是特殊的数组
      * 语法与数组相同, 支持使用`?:`创建可选元素
      * 最小长度固定, 各索引位上的值有固定的已知类型
      * 声明时必须显式声明类型
    * 声明元组
      * 固定长度: `let a: [string, string, number]`
      * 可变长度: `let b: [string, ...string]`
      * 可选元素: `let c: [number?]`
* `null`、`undefined`、`void`和`never`
  * `null`: 缺少值
  * `undefined`: 尚未定义
  * `void`: 函数没有显式返回任何值
  * `never`: 函数不返回时(抛出异常、永远执行等情况)使用的类型. 兜底类型, 可以赋给其他任何类型
* 枚举
  * 语法
    ```typescript
    enum Language { 
      English, 
      Spanish 
    }
    ```
  * 访问枚举
    ```typescript
    let a = Language.English
    let b = Language['Spanish']
    let c = Language[0]
    ```
  * 访问限制
    * `const enum`: 访问枚举值时, 只允许使用`.`的方式访问
      ```json
      {
        "complierOptions": {
          "preserveConstEnums": true
        }
      }
      ```
# 四-函数
## 声明及调用函数
* 声明函数的方法
  * 具名函数: `function greet(name: string) { return 'hello' + name }`
  * 函数表达式: `let greet2 = function(name: string) { return 'hello' + name }`
  * 箭头函数表达式: `let greet3 = (name: string) => { return 'hello' + name } // 单行函数体可以去掉括号`
  * 函数构造: `let greet4 = new Function('name', 'return "hello" + name')`
* 可选及默认参数
  * 可选参数: `function f(name?: string) {}`
  * 默认参数: `function f(name = 'Lisa') {}`
  * 剩余参数: `function f(...numbers: number[]) {}`